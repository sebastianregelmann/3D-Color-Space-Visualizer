#pragma kernel InitRGBMap
#pragma kernel WriteToRGBMap
#pragma kernel FilterRGBMap
#pragma kernel InitWorkBuffer
#pragma kernel AnimatePositions

// Inputs
Texture2D<float4> _Texture;

struct Data{
    float4 color;
    float3 position;
    int count;
};

// Outputs
RWStructuredBuffer<Data> _RGBMap; //255 * 255 * 255 entry for each RGB Value
RWStructuredBuffer<uint> _RGBCounts; //Number of Colors in _AllData that have the same value size is also 255*255*255
AppendStructuredBuffer<Data> _UniqueRGB;
RWStructuredBuffer<float3> _TargetPositions;
StructuredBuffer<Data> _UniqueRGBRead;
RWStructuredBuffer<Data> _FinalRGBRead;
RWStructuredBuffer<Data> _FinalHSVRead;
RWStructuredBuffer<Data> _WorkOnData;

RWStructuredBuffer<Data> _CurrentData;



// Variables for all kernels
uint _Width;
uint _Height;
float _T;
int _ColorSpace;
int _AnimationDirection;




[numthreads(8,8,8)]
void InitRGBMap (uint3 id : SV_DispatchThreadID)
{
    uint3 index = id.xyz;
    if(index.r >= 255 || index.g >= 255 || index.b >= 255)
    {
        return;
    }

    //Convert thrad index into a linear index based on the RGB Values
    uint colorIndex = index.b * 255 * 255 + index.g * 255 + index.r;

    float4 color = float4(float(index.r) / 255.0, float(index.g) / 255.0, float(index.b) / 255.0, 1.0);
    float3 position = color.rgb;
    float count = 0;

    Data data;
    data.color = color;
    data.position = position;
    data.count = count;

    _RGBMap[colorIndex] = data; //Set Data
    _RGBCounts[colorIndex] = 0; // Reset count

}

[numthreads(32,32,1)]
void WriteToRGBMap (uint3 id : SV_DispatchThreadID)
{
    uint2 index = id.xy;

    if(index.x >= _Width || index.y >= _Height)
    {
        return;
    }


    //Get the color from the Texture
    float3 color = _Texture[index.xy].rgb;


    //Get the index from the color
    int r = int(ceil(color.r * 255));
    int g = int(ceil(color.g * 255));
    int b = int(ceil(color.b * 255));

    int colorIndex = b * 255 * 255 + g * 255 + r;

    //Atomic Add to increase the counter of _RGBMap by one at the colorIndex
    uint tmp;
    InterlockedAdd(_RGBCounts[colorIndex], 1, tmp);
}


[numthreads(8,8,8)]
void FilterRGBMap (uint3 id : SV_DispatchThreadID)
{

    uint3 index = id.xyz;
    if(index.r >= 255 || index.g >= 255 || index.b >= 255)
    {
        return;
    }

    //Convert thrad index into a linear index based on the RGB Values
    uint colorIndex = index.b * 255 * 255 + index.g * 255 + index.r;

    Data data = _RGBMap[colorIndex];
    uint count = _RGBCounts[colorIndex];

    //If data is not Present Skip it
    if(count <= 0)
    {
        return;
    }

    //Save the unique Data
    Data unique;
    unique.color = data.color;
    unique.position = data.position;
    unique.count = count;

    _UniqueRGB.Append(unique);
}


//Creates a RGB Data struct
Data DataRGB(Data inputdata)
{
    Data data;
    data.color = inputdata.color;
    data.position = inputdata.color.rgb;
    data.count = inputdata.count;

    return data;
}

//converts a float3 rgb value to a float3 hcv value
float3 RGBtoHCV(in float3 rgb)
{
    float epsilon = 0.0000000001;

    // Based on work by Sam Hocevar and Emil Persson
    float4 P = (rgb.g < rgb.b) ? float4(rgb.bg, - 1.0, 2.0 / 3.0) : float4(rgb.gb, 0.0, - 1.0 / 3.0);
    float4 Q = (rgb.r < P.x) ? float4(P.xyw, rgb.r) : float4(rgb.r, P.yzx);
    float C = Q.x - min(Q.w, Q.y);
    float H = abs((Q.w - Q.y) / (6 * C + epsilon) + Q.z);
    return float3(H, C, Q.x);
}

//converts a float3 rgb value to a float3 hsv value
float3 RGBtoHSV(float3 rgb)
{
    float epsilon = 0.0000000001;
    float3 HCV = RGBtoHCV(rgb);
    float S = HCV.y / (HCV.z + epsilon);
    return float3(HCV.x, S, HCV.z);
}

//Creates a HSV data struct
Data DataHSV(Data inputdata)
{
    Data data;
    data.color = inputdata.color;
    data.position = RGBtoHSV(inputdata.color.rgb);
    data.count = inputdata.count;

    return data;
}


[numthreads(512,1,1)]
void InitWorkBuffer (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    uint uniqueCount = _RGBCounts[0]; //Read how many values are in _UniqueRGBRead

    if (index >= uniqueCount)
    {
        return;
    }

    //Read the Data that is being Copied
    Data data = _UniqueRGBRead[index];

    //Create the data in RGB and HSV format
    Data dataRGB = DataRGB(data);
    Data dataHSV = DataHSV(data);

    //Copy the data to the final read buffers
    _FinalRGBRead[index] = dataRGB;
    _FinalHSVRead[index] = dataHSV;

    if(_ColorSpace == 0)
    {
        _WorkOnData[index] = dataRGB;
    }
    else if(_ColorSpace == 1)
    {
        _WorkOnData[index] = dataHSV;
    }
}





[numthreads(512,1,1)]
void AnimatePositions (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    uint uniqueCount = _RGBCounts[0]; //Read how many values are in _UniqueRGBRead

    if (index >= uniqueCount)
    {
        return;
    }

    float3 targetPosition;
    float3 originPosition;

    if(_AnimationDirection == 0)
    {
        targetPosition = _FinalHSVRead[index].position;
        originPosition = _FinalRGBRead[index].position;
    }
    else if(_AnimationDirection == 1)
    {
        targetPosition = _FinalRGBRead[index].position;
        originPosition = _FinalHSVRead[index].position;
    }
    else
    {
        targetPosition = 0;
        originPosition = 0;
    }

    //Calculate the new Position
    float3 newPosition = lerp(originPosition, targetPosition, _T);


    //Get the data that is currently worked on
    Data data = _WorkOnData[index];

    //Update the data
    Data updatedData;
    updatedData.color = data.color;
    updatedData.position = newPosition;
    updatedData.count = data.count;

    //Save the updated Data
    _WorkOnData[index] = updatedData;
}