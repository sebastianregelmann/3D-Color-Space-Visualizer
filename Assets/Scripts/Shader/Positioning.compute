#pragma kernel InitRGBMap
#pragma kernel WriteToRGBMap
#pragma kernel FilterRGBMap
#pragma kernel InitMovementBufferRGB
#pragma kernel MovePositionsRGB
// Inputs
Texture2D<float4> _Texture;

struct Data{
    float4 color;
    float3 position;
    int count;
};

// Outputs
RWStructuredBuffer<Data> _RGBMap; //255 * 255 * 255 entry for each RGB Value
RWStructuredBuffer<uint> _RGBCounts; //Number of Colors in _AllData that have the same value size is also 255*255*255
AppendStructuredBuffer<Data> _UniqueRGB;
RWStructuredBuffer<float3> _TargetPositions;
RWStructuredBuffer<Data> _CurrentData;
StructuredBuffer<Data> _UniqueRGBRead;
// Variables for all kernels
uint _Width;
uint _Height;
float _T;




[numthreads(8,8,8)]
void InitRGBMap (uint3 id : SV_DispatchThreadID)
{
    uint3 index = id.xyz;
    if(index.r >= 255 || index.g >= 255 || index.b >= 255)
    {
        return;
    }

    //Convert thrad index into a linear index based on the RGB Values
    uint colorIndex = index.b * 255 * 255 + index.g * 255 + index.r;

    float4 color = float4(float(index.r) / 255.0, float(index.g) / 255.0, float(index.b) / 255.0, 1.0);
    float3 position = color.rgb;
    float count = 0;

    Data data;
    data.color = color;
    data.position = position;
    data.count = count;

    _RGBMap[colorIndex] = data; //Set Data
    _RGBCounts[colorIndex] = 0; // Reset count

}

[numthreads(32,32,1)]
void WriteToRGBMap (uint3 id : SV_DispatchThreadID)
{


    uint2 index = id.xy;
    uint total = _Width * _Height;

    if(index.x >= _Width || index.y >= _Height)
    {
        return;
    }


    //Get the color from the Texture
    float3 color = _Texture[index.xy].rgb;


    //Get the index from the color
    int r = int(ceil(color.r * 255));
    int g = int(ceil(color.g * 255));
    int b = int(ceil(color.b * 255));

    int colorIndex = b * 255 * 255 + g * 255 + r;

    //Atomic Add to increase the counter of _RGBMap by one at the colorIndex
    uint tmp;
    InterlockedAdd(_RGBCounts[colorIndex], 1, tmp);
}


[numthreads(8,8,8)]
void FilterRGBMap (uint3 id : SV_DispatchThreadID)
{

    uint3 index = id.xyz;
    if(index.r >= 255 || index.g >= 255 || index.b >= 255)
    {
        return;
    }

    //Convert thrad index into a linear index based on the RGB Values
    uint colorIndex = index.b * 255 * 255 + index.g * 255 + index.r;

    Data data = _RGBMap[colorIndex];
    uint count = _RGBCounts[colorIndex];

    //If data is not Present Skip it
    if(count <= 0)
    {
        return;
    }

    //Save the unique Data
    Data unique;
    unique.color = data.color;
    unique.position = data.position;
    unique.count = count;

    _UniqueRGB.Append(unique);
}


[numthreads(512,1,1)]
void InitMovementBufferRGB (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    uint uniqueCount = _RGBCounts[0]; //Read how many values are in _UniqueRGBRead

    if (index >= uniqueCount)
    {
        return;
    }


    //Init the Target Position Buffer
    _TargetPositions[index] = float3(1, 1, 1);

    Data data = _UniqueRGBRead[index];

    //Copy the data to the other Buffer
    Data currentData;
    currentData.color = data.color;
    currentData.position = data.position;
    currentData.count = data.count;
    _CurrentData[index] = currentData;
}


[numthreads(512,1,1)]
void MovePositionsRGB (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    uint uniqueCount = _RGBCounts[0]; //Read how many values are in _UniqueRGBRead

    if (index >= uniqueCount)
    {
        return;
    }

    float3 target = _TargetPositions[index];
    float3 origin = _UniqueRGBRead[index].position;

    //Get the data
    Data data = _CurrentData[index];
    //Update the position
    float3 newPosition = lerp(origin, target, _T);

    Data updatedData;
    updatedData.color = data.color;
    updatedData.position = newPosition;
    updatedData.count = data.count;

    //Save the updated Data
    _CurrentData[index] = updatedData;
}