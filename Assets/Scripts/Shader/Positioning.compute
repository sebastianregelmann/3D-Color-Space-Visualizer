#pragma kernel WritePositionsRGB
#pragma kernel CombineDublicatesRGB

// Inputs
Texture2D<float4> _Texture;

struct Data{
    float4 color;
    float3 position;
    int count;
};

// Outputs
RWStructuredBuffer<Data> _AllData; // Size is _Width * _Height
AppendStructuredBuffer<Data> _CombinedData;

// Variables for all kernels
uint _Width;
uint _Height;

[numthreads(8,8,1)]
void WritePositionsRGB (uint3 id : SV_DispatchThreadID)
{
    // Exit early if outside bounds
    if (id.x >= _Width || id.y >= _Height)
    {
        return;
    }

    // Sample color from texture
    float4 color = _Texture[id.xy].rgba;

    //Create a Data element of the color
    Data data;
    data.color = color;
    data.position = color.rgb;
    data.count = 1;

    // Calculate 1D index into buffer
    int index = id.y * _Width + id.x;

    // Store RGB values into buffer
    _AllData[index] = data;
}


[numthreads(64,1,1)]
void CombineDublicatesRGB (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    uint total = _Width * _Height;

    if (index >= total)
        return;

    Data current = _AllData[index];
    float3 color = current.color;

    // Step 1: Check for duplicate earlier in list
    for (uint i = 0; i < index; i++)
    {
        if (all(_AllData[i].color.rgb == color))
        {
            // Duplicate found earlier, skip this one
            return;
        }
    }

    // Step 2: Count occurrences of this color in entire buffer
    int count = 0;
    for (uint i = 0; i < total; i++)
    {
        if (all(_AllData[i].color.rgb == color))
        {
            count++;
        }
    }

    // Step 3: Create unique data entry
    Data unique;
    unique.color = current.color;
    unique.position = color;
    unique.count = count;

    _CombinedData.Append(unique);
}